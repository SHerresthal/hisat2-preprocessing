import yaml

include: "/scripts/snakemake-scripts.py"

configfile: "/config/config.yml"

fastqdir = "/fastq"
samples = get_samples(fastqdir)
config = parse_config(config, samples)

# "/meta/hisat2"
indexdir = str(Path(config['metadir'])/"hisat2")
# "/meta/genome.fasta"
fastafile = str(Path(config['metadir'])/config['fasta'])
# "genome"
indexname = str(Path(config['fasta']).stem)
# "/meta/hisat2/genome"
indexstem = str(Path(indexdir)/indexname)
# "/meta/annotation.gtf"
gtffile = str(Path(config['metadir'])/config['gtf'])
bedfile = str(Path(gtffile).with_suffix(".bed"))

indexfiles = expand(
    indexstem+".{i}.ht2",
    i=range(1,9))


rule all:
    input:
        "config.yml",
        # count vectors
        expand("counts/{sample}.tsv", sample=samples.keys()),
        # qc from htseq_qc
        expand("qc/htseq_qc/{sample}.pdf", sample=samples.keys()),
        # multiqc outputs
        "qc/multiqc/summary.html",
        "qc/multiqc/fastqc.html"


# writes the updated config file to the output directory
rule storeconfig:
    output:
        "config.yml"
    run:
        with open(output[0],"w") as f:
            yaml.dump(config, f, default_flow_style=False)


rule clean:
    shell:
        "rm -rf /output/* /index/*.gff /index/*.bed /index/hisat2/*"


rule samtools_sort:
    input:
        "mapped/unsorted/{sample}.bam"
    output:
        "mapped/sorted/{sample}.bam"
    params:
        "-m 4G"
    threads: 8
    wrapper:
        "0.2.0/bio/samtools/sort"


rule htseq:
    input:
        bam="mapped/sorted/{sample}.bam",
        gtf=gtffile
    output:
        "counts/{sample}.tsv"
    log:
        "logs/htseq/{sample}.log"
    shell:
        """htseq-count --order=pos --format=bam \
        {input.bam} {input.gtf} > {output} 2> {log}"""


rule multiqc_summary:
    input:
        expand("counts/{sample}.tsv", sample=samples.keys()),
        expand("logs/hisat2/{sample}.log", sample=samples.keys()),
        expand("qc/rseqc/{sample}.rseqc.txt", sample=samples.keys()),
    output:
        "qc/multiqc/summary.html"
    params:
        ""
    log:
        "logs/multiqc.log"
    wrapper:
        "0.27.1/bio/multiqc"


rule multiqc_fastqc:
    input:
        expand("qc/fastqc/{sample}_R{read}_fastqc.zip",
               sample=samples.keys(),
               read=[1, 2] if config['mode']=="paired" else [1])
    output:
        "qc/multiqc/fastqc.html"
    params:
        ""
    log:
        "logs/multiqc.log"
    wrapper:
        "0.27.1/bio/multiqc"


rule htseq_qa:
    input:
        "mapped/sorted/{sample}.bam",
    output:
        "qc/htseq_qc/{sample}.pdf"
    shell:
        """htseq-qa --type=bam {input} --outfile={output} --maxqual=60"""


rule hisat2index:
    input:
        fastafile
    output:
        indexfiles
    log:
        "logs/hisat2-index.log"
    shell:
        "cd " + indexdir + " && "
        "hisat2-build {input} " + indexname


rule hisat2:
    input:
        # the function below selects either single or paired inputs
        # depending on the option 'mode'
        index=indexfiles,
        # reads=lambda wildcards: hisat2_input(
        #     wildcards, config['mode'])
        reads=lambda wildcards: hisat2_input(
            wildcards, config['mode'])
    output:
        temp("mapped/unsorted/{sample}.bam")
    log:
        "logs/hisat2/{sample}.log"
    params:
        idx=indexstem,
        extra="--new-summary"
    threads: 8
    wrapper:
        "0.27.1/bio/hisat2"


rule merge:
    input:
        lambda wildcards: samples[wildcards.sample][wildcards.read]
    output:
        temp("merged/{sample}_R{read}.fastq")
    log:
        "logs/merging/{sample}_R{read}_merge.log"
    shell:
        """
        echo {input} | tr ' ' '\n' > {log};
        zcat {input} > {output}"""


rule fastqc:
    input:
        "merged/{sample}_R{read}.fastq"
    output:
        html="qc/fastqc/{sample}_R{read}_fastqc.html",
        zip="qc/fastqc/{sample}_R{read}_fastqc.zip"
    params: ""
    log:
        "logs/fastqc/{sample}_R{read}.log"
    wrapper:
        "0.27.1/bio/fastqc"


rule gtf2bed:
    input:
        gtffile
    output:
        bedfile
    shell:
        "/scripts/gtf2bed {input} > {output}"


rule rseqc:
    input:
        bam="mapped/sorted/{sample}.bam",
        bed=bedfile
    output:
        "qc/rseqc/{sample}.rseqc.txt"
    shell:
        """
        source activate rseqc
        read_distribution.py -i {input.bam} -r {input.bed} > {output}
        """
